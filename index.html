<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Err Craft</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        /* --- CSS VARIABLES & COLORS --- */
        :root {
            --ui-bg: rgba(0, 0, 0, 0.7);
            --ui-border: 2px solid rgba(255, 255, 255, 0.4);
            --selected: #ffeb3b;
            --heart-full: #ff3333;
            --heart-lost: #441111;
        }

        /* --- BODY & RESET --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            font-family: 'VT323', monospace;
            user-select: none;
        }

        /* --- CONTAINERS --- */
        #game-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* --- DAMAGE EFFECT --- */
        #damage-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: red;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
            z-index: 50;
        }
        .flash-active {
            opacity: 0.4 !important;
        }

        /* --- STATS HUD (Hearts / Level / XP) --- */
        #stats-hud {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            pointer-events: none;
        }

        #hearts-container {
            display: flex;
            gap: 2px;
            margin-bottom: 5px;
            text-shadow: 2px 2px 0 #000;
        }

        .heart {
            font-size: 24px;
            color: var(--heart-lost);
            transition: color 0.2s;
        }
        .heart.full {
            color: var(--heart-full);
        }

        #level-tag {
            font-size: 20px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            margin-bottom: 2px;
        }

        #exp-bar-container {
            width: 300px;
            height: 10px;
            background: #333;
            border: 2px solid rgba(0,0,0,0.5);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        #exp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #81C784);
            width: 0%;
            transition: width 0.3s ease-out;
            box-shadow: 0 0 5px #4CAF50;
        }

        /* --- INVENTORY & WEAPONS UI --- */
        #weapon-view {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 128px;
            height: 128px;
            image-rendering: pixelated;
            z-index: 15;
            pointer-events: none;
        }
        #weapon-canvas {
            width: 128px;
            height: 128px;
            image-rendering: pixelated;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 24px;
            height: 24px;
            transform: translate(-50%, -50%);
            z-index: 10;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.9);
            transition: background 0.2s;
        }
        #crosshair::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
        #crosshair::after { width: 100%; height: 2px; top: 50%; transform: translateY(-50%); }

        #hotbar {
            align-self: center;
            margin-bottom: 20px;
            background: var(--ui-bg);
            border: var(--ui-border);
            padding: 8px;
            border-radius: 6px;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            pointer-events: auto;
            backdrop-filter: blur(4px);
            max-width: 90%;
            justify-content: center;
        }

        #weapon-bar {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--ui-bg);
            border: var(--ui-border);
            padding: 10px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
            backdrop-filter: blur(4px);
        }

        /* --- SLOT STYLING --- */
        .weapon-slot {
            display: flex;
            align-items: center;
            color: white;
            font-size: 20px;
            padding: 5px 10px;
            border-radius: 4px;
            background: rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.1);
            transition: all 0.1s ease;
        }
        .weapon-slot.active {
            background: rgba(50, 50, 50, 0.8);
            border-color: var(--selected);
            transform: scale(1.05);
            box-shadow: 0 0 5px var(--selected);
        }
        .weapon-key { font-size: 14px; color: #aaa; margin-right: 10px; font-weight: bold; }

        .slot {
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 16px;
            position: relative;
            background: rgba(0,0,0,0.3);
            transition: all 0.1s ease;
        }
        .slot.active {
            border-color: var(--selected);
            transform: scale(1.2);
            background: rgba(50, 50, 50, 0.8);
            box-shadow: 0 0 10px var(--selected);
            z-index: 1;
        }
        .slot-key {
            position: absolute;
            top: 1px;
            left: 2px;
            font-size: 12px;
            color: #aaa;
            font-weight: bold;
        }
        .slot-preview {
            width: 24px;
            height: 24px;
            border: 1px solid rgba(0,0,0,0.5);
        }

        /* --- MENU & OVERLAYS --- */
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            pointer-events: auto;
            z-index: 20;
            text-align: center;
        }
        #menu h1 {
            font-size: 72px;
            margin: 0 0 10px 0;
            text-shadow: 4px 4px 0 #000;
            color: #4CAF50;
            letter-spacing: 2px;
        }
        #menu p { font-size: 24px; line-height: 1.6; margin: 5px 0; color: #ddd; }
        #start-btn {
            margin-top: 30px;
            padding: 15px 50px;
            font-family: 'VT323', monospace;
            font-size: 36px;
            background: #4CAF50;
            color: white;
            border: none;
            border-bottom: 6px solid #2E7D32;
            cursor: pointer;
            transition: all 0.1s;
        }
        #start-btn:hover { background: #66BB6A; }
        #start-btn:active { border-bottom: 0px solid #2E7D32; transform: translateY(6px); }
        .hidden { display: none !important; }

        #hud-info {
            position: absolute;
            top: 15px;
            left: 15px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }
    </style>
    <!-- --- IMPORT MAPS FOR THREE.JS --- -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- --- GAME LAYERS --- -->
    <div id="game-container"></div>
    <div id="damage-overlay"></div>

    <div id="ui-layer">
        <div id="hud-info">Weapon: Sword</div>
        <div id="crosshair"></div>
        
        <div id="stats-hud">
            <div id="level-tag">Level 1</div>
            <div id="hearts-container">
                <!-- Hearts generated by JS -->
            </div>
            <div id="exp-bar-container">
                <div id="exp-bar-fill"></div>
            </div>
        </div>

        <div id="hotbar"></div>
        <div id="weapon-view"><canvas id="weapon-canvas" width="128" height="128"></canvas></div>
        <div id="weapon-bar"></div> 
    </div>

    <!-- --- START MENU --- -->
    <div id="menu">
        <h1>ERR CRAFT</h1>
        <p>WASD to Move | SHIFT to Sprint</p>
        <p>NUMS 1-0: Switch Blocks</p>
        <p>SCROLL WHEEL: Switch Weapons</p>
        <p>Left Click: Attack/Teleport/Shoot | Right Click: Build</p>
        <button id="start-btn">START GAME</button>
    </div>

    <!-- --- MAIN GAME SCRIPT --- -->
    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONFIGURATION & CONSTANTS ---
        const BLOCK_SIZE = 1;
        const CHUNK_SIZE = 64; 
        
        // --- BLOCK DATA --- 
        // Defines all block types, colors, and textures styles
        const BLOCKS = [
            { id: 1, name: 'Grass', color: '#5C9E63', sideColor: '#5C4033', style: 'grass' },
            { id: 2, name: 'Stone', color: '#7d7d7d', style: 'stone' },
            { id: 3, name: 'Dirt', color: '#5C4033', style: 'dirt' },
            { id: 4, name: 'Wood', color: '#654321', style: 'wood' },
            { id: 5, name: 'Leaves', color: '#4a7c32', style: 'leaves' },
            { id: 6, name: 'Bricks', color: '#A05A2C', style: 'bricks' },
            { id: 7, name: 'Sand', color: '#C2B280', style: 'sand' },
            { id: 8, name: 'Gold', color: '#FFD700', style: 'gold' },
            { id: 9, name: 'Diamond', color: '#00FFFF', style: 'diamond' },
            { id: 10, name: 'Obsidian', color: '#1a1028', style: 'obsidian' }
        ];

        // --- WEAPON DATA ---
        // Defines weapon stats like damage and type
        const WEAPONS = [
            { id: 0, name: 'Sword', damage: 50, range: 5, speed: 0, type: 'melee', color: '#ff4444' },
            { id: 1, name: 'Bow', damage: 30, range: 10, speed: 0, type: 'ranged', color: '#44ff44' }, 
            { id: 2, name: 'Ender Eye', damage: 0, range: 50, speed: 0, type: 'magic', color: '#b026ff' },
            { id: 3, name: 'Trident', damage: 60, range: 20, speed: 0, type: 'throwable', color: '#00ffff' }, 
            { id: 4, name: 'Crossbow', damage: 45, range: 15, speed: 0, type: 'ranged_heavy', color: '#885522' } 
        ];

        // --- GLOBAL VARIABLES ---
        let camera, scene, renderer, controls;
        let raycaster;
        const objects = []; // Stores all placeable blocks
        const mobs = [];     // Stores all enemies
        const projectiles = []; // Stores arrows, bolts, etc.
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let sprint = false;
        let canJump = false;
        
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        
        let selectedBlockIndex = 0;
        let selectedWeaponIndex = 0;
        let rollOverMesh; // The wireframe box showing where we are looking
        
        const materials = {};

        // --- RPG STATS STATE ---
        // Tracks player health, level, and experience
        const playerStats = {
            maxHp: 20, 
            hp: 20,
            level: 1,
            xp: 0,
            xpToNext: 100,
            fallDistance: 0,
            isDead: false
        };

        // --- TEXTURE GENERATOR ---
        // Instead of loading images, we draw textures on the fly using Canvas API
        function createProceduralTexture(blockDef) {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = blockDef.color;
            ctx.fillRect(0, 0, size, size);

            const drawNoise = (amount, color = 'rgba(0,0,0,0.15)') => {
                ctx.fillStyle = color;
                for(let i=0; i<amount; i++) {
                    const s = Math.random() * 4 + 1;
                    ctx.fillRect(Math.random()*size, Math.random()*size, s, s);
                }
            };

            if (blockDef.style === 'grass') {
                drawNoise(150, 'rgba(0,0,0,0.1)');
                ctx.fillStyle = 'rgba(100, 200, 100, 0.2)';
                for(let i=0; i<50; i++) ctx.fillRect(Math.random()*size, Math.random()*size, 2, 4);
            } 
            else if (blockDef.style === 'dirt') {
                drawNoise(200, 'rgba(0,0,0,0.15)');
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                for(let i=0; i<20; i++) ctx.fillRect(Math.random()*size, Math.random()*size, 3, 3);
            }
            else if (blockDef.style === 'stone') {
                drawNoise(300, 'rgba(0,0,0,0.2)');
                ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                ctx.beginPath();
                ctx.moveTo(10, 10); ctx.lineTo(30, 30); ctx.lineTo(50, 20);
                ctx.stroke();
            }
            else if (blockDef.style === 'wood') {
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                for(let i=0; i<8; i++) ctx.fillRect(Math.random()*size, 0, 2 + Math.random()*2, size);
                drawNoise(100);
            }
            else if (blockDef.style === 'leaves') {
                drawNoise(400, 'rgba(0,0,0,0.3)');
                ctx.fillStyle = 'rgba(0,50,0,0.3)';
                for(let i=0; i<50; i++) ctx.fillRect(Math.random()*size, Math.random()*size, 6, 6);
            }
            else if (blockDef.style === 'bricks') {
                ctx.fillStyle = 'rgba(0,0,0,0.3)'; 
                ctx.fillRect(0, 15, size, 2); ctx.fillRect(0, 31, size, 2); ctx.fillRect(0, 47, size, 2);
                ctx.fillRect(15, 0, 2, 15); ctx.fillRect(31, 0, 2, 15); ctx.fillRect(47, 0, 2, 15);
                ctx.fillRect(7, 16, 2, 15); ctx.fillRect(23, 16, 2, 15); ctx.fillRect(39, 16, 2, 15); ctx.fillRect(55, 16, 2, 15);
            }
            else if (blockDef.style === 'sand') drawNoise(200, 'rgba(150,100,0,0.1)');
            else if (blockDef.style === 'gold' || blockDef.style === 'diamond') {
                drawNoise(50);
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                for(let i=0; i<30; i++) {
                    const x = Math.random()*size, y = Math.random()*size;
                    ctx.fillRect(x, y, 2, 2); ctx.fillRect(x+1, y+1, 2, 2);
                }
            }
            else if (blockDef.style === 'obsidian') {
                drawNoise(500, 'rgba(0,0,0,0.5)');
                ctx.fillStyle = 'rgba(50,0,50,0.1)';
                ctx.fillRect(10,10, size/2, size/2);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        // --- WEAPON ICON DRAWER ---
        // Draws weapon icons on 2D canvas based on weapon ID
        function drawWeaponTexture(weapon) {
            const canvas = document.getElementById('weapon-canvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width;
            const h = canvas.height;

            ctx.clearRect(0, 0, w, h);
            
            const pSize = 8;
            
            if (weapon.id === 0) { // Sword
                ctx.fillStyle = '#5c4033'; 
                ctx.fillRect(w/2 - 2, h/2, 4, 40);
                ctx.fillStyle = '#a0a0a0'; 
                ctx.fillRect(w/2 - 6, h/2 - 40, 12, 40);
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(w/2 - 4, h/2 + 2, 8, 4);
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillRect(w/2 - 6, h/2 - 38, 2, 30);
            }
            else if (weapon.id === 1) { // NORMAL Bow
                ctx.fillStyle = '#5c4033'; 
                ctx.beginPath();
                ctx.arc(w/2, h/2, 20, Math.PI, 0, Math.PI, false);
                ctx.lineWidth = 4;
                ctx.strokeStyle = '#8b4513';
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(w/2 - 20, h/2);
                ctx.quadraticCurveTo(w/2, h/2 + 20, w/2 + 20, h/2);
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#eee';
                ctx.stroke();
            }
            else if (weapon.id === 2) { // Ender Eye
                ctx.fillStyle = 'rgba(176, 38, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(w/2, h/2, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#b026ff';
                ctx.beginPath();
                ctx.moveTo(w/2 - 12, h/2 - 10);
                ctx.lineTo(w/2 + 12, h/2 - 10);
                ctx.quadraticCurveTo(w/2 + 14, h/2 + 10, w/2, h/2 + 14);
                ctx.quadraticCurveTo(w/2 - 14, h/2 + 10, w/2 - 12, h/2 - 10);
                ctx.fill();
                ctx.fillStyle = '#e080ff';
                ctx.beginPath();
                ctx.ellipse(w/2, h/2, 5, 7, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.ellipse(w/2, h/2, 2, 4, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            else if (weapon.id === 3) { // STRONGER Trident
                ctx.fillStyle = '#555555';
                ctx.fillRect(w/2 - 2, h/2 - 50, 4, 100);
                
                ctx.fillStyle = '#aaaaaa';
                ctx.fillRect(w/2 - 3, h/2 - 60, 6, 12);
                ctx.fillRect(w/2 - 1, h/2 - 70, 2, 12);
                
                ctx.fillRect(w/2 - 6, h/2 - 45, 6, 12);
                ctx.fillRect(w/2 - 4, h/2 - 55, 2, 12);
                
                ctx.fillRect(w/2 + 0, h/2 - 45, 6, 12);
                ctx.fillRect(w/2 + 2, h/2 - 55, 2, 12);
                
                ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
                ctx.beginPath();
                ctx.arc(w/2, h/2 - 40, 30, 0, Math.PI*2);
                ctx.fill();
            }
            else if (weapon.id === 4) { // Crossbow
                ctx.fillStyle = '#5c4033';
                ctx.fillRect(w/2 - 4, h/2 - 10, 8, 50);
                ctx.fillStyle = '#3e2723';
                ctx.fillRect(w/2 - 15, h/2 - 5, 30, 6);
                ctx.strokeStyle = '#eee';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(w/2 - 15, h/2 - 5);
                ctx.lineTo(w/2 + 15, h/2 - 5);
                ctx.stroke();
                ctx.fillStyle = '#111';
                ctx.fillRect(w/2 - 1, h/2 - 5, 2, 20);
            }
        }

        // --- RPG UI UPDATES ---
        // Functions to update hearts and XP bar in DOM
        function initRPGUI() {
            updateHeartsUI();
            updateExpUI();
        }

        function updateHeartsUI() {
            const container = document.getElementById('hearts-container');
            container.innerHTML = '';
            const numHearts = Math.ceil(playerStats.maxHp / 2);
            for (let i = 0; i < numHearts; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heart.textContent = 'â™¥';
                const heartValue = (i + 1) * 2;
                if (playerStats.hp >= heartValue) {
                    heart.classList.add('full');
                } else {
                    if(playerStats.hp > i*2) heart.style.color = '#ff8888'; 
                }
                container.appendChild(heart);
            }
        }

        function updateExpUI() {
            const fill = document.getElementById('exp-bar-fill');
            const tag = document.getElementById('level-tag');
            const pct = Math.min(100, (playerStats.xp / playerStats.xpToNext) * 100);
            fill.style.width = `${pct}%`;
            tag.textContent = `Level ${playerStats.level}`;
        }

        function addExp(amount) {
            if (playerStats.isDead) return;
            playerStats.xp += amount;
            
            // Check for level up
            while (playerStats.xp >= playerStats.xpToNext) {
                playerStats.xp -= playerStats.xpToNext;
                playerStats.level++;
                playerStats.xpToNext = Math.floor(playerStats.xpToNext * 1.2);
                playerStats.maxHp += 2;
                playerStats.hp = playerStats.maxHp; 
                
                // Visual flash for level up
                const flash = document.createElement('div');
                flash.style.position = 'absolute';
                flash.style.top = '0'; flash.style.left = '0';
                flash.style.width = '100%'; flash.style.height = '100%';
                flash.style.background = 'rgba(0, 255, 0, 0.3)';
                flash.style.pointerEvents = 'none'; flash.style.transition = 'opacity 0.5s';
                flash.style.zIndex = '100'; document.body.appendChild(flash);
                setTimeout(() => { flash.style.opacity = '0'; setTimeout(() => flash.remove(), 500); }, 50);
            }
            updateHeartsUI();
            updateExpUI();
        }

        function takeDamage(amount) {
            if (playerStats.isDead) return;
            playerStats.hp = Math.max(0, playerStats.hp - amount);
            updateHeartsUI();

            // Red screen flash
            const overlay = document.getElementById('damage-overlay');
            overlay.classList.add('flash-active');
            setTimeout(() => {
                overlay.classList.remove('flash-active');
            }, 200);

            if (playerStats.hp <= 0) {
                playerDie();
            }
        }

        function playerDie() {
            if (playerStats.isDead) return; 
            playerStats.isDead = true;
            
            controls.unlock();

            // Wait a bit then respawn
            setTimeout(() => {
                playerRespawn();
            }, 300);
        }

        function playerRespawn() {
            playerStats.isDead = false;
            playerStats.hp = playerStats.maxHp;
            playerStats.fallDistance = 0;
            
            // Reset player position and physics
            controls.getObject().position.set(0, 5, 0);
            velocity.set(0, 0, 0);
            camera.rotation.set(0, 0, 0);
            
            updateHeartsUI();
            
            // Show menu again
            document.getElementById('menu').classList.remove('hidden');
        }

        // --- PROJECTILE CLASSES ---
        // Handles physics and movement of arrows, bolts, and magic projectiles

        // --- Projectile System: Normal Arrow ---
        class Arrow {
            constructor(position, direction, damage) {
                this.damage = damage;
                this.lifeTime = 4.0; 
                this.mesh = new THREE.Group();
                this.mesh.position.copy(position);
                const offset = direction.clone().cross(new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(0.2);
                this.mesh.position.add(offset);
                this.mesh.position.y -= 0.2;
                const shaft = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 1.0), new THREE.MeshLambertMaterial({ color: 0x8B4513 }));
                this.mesh.add(shaft);
                const head = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.3, 4), new THREE.MeshLambertMaterial({ color: 0x555555 }));
                head.rotation.x = Math.PI / 2; head.position.set(0, 0, 0.65); 
                this.mesh.add(head);
                const f1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.02, 0.15), new THREE.MeshLambertMaterial({ color: 0xffffff }));
                f1.position.set(0.1, 0, -0.55); this.mesh.add(f1);
                const f2 = f1.clone(); f2.position.set(-0.1, 0, -0.55); this.mesh.add(f2);
                this.velocity = direction.clone().normalize().multiplyScalar(45); 
                this.gravity = new THREE.Vector3(0, -15, 0); 
                this.stuck = false;
                scene.add(this.mesh);
            }
            update(delta) {
                if (this.stuck || playerStats.isDead) return; 
                this.lifeTime -= delta;
                this.velocity.add(this.gravity.clone().multiplyScalar(delta));
                const displacement = this.velocity.clone().multiplyScalar(delta);
                const nextPosition = this.mesh.position.clone().add(displacement);
                const targetLook = this.mesh.position.clone().add(this.velocity);
                this.mesh.lookAt(targetLook);
                const direction = displacement.clone().normalize();
                const ray = new THREE.Raycaster(this.mesh.position, direction, 0, displacement.length());
                const allHits = [...ray.intersectObjects(objects), ...ray.intersectObjects(mobs.map(m => m.mesh), true)];
                if (allHits.length > 0) {
                    const hit = allHits[0];
                    const object = hit.object;
                    this.mesh.position.copy(hit.point).add(direction.clone().multiplyScalar(-0.1));
                    if (object.parent && object.parent.userData && object.parent.userData.type === 'mob') {
                        object.parent.userData.mobRef.hit(this.damage);
                        this.kill(); 
                        return; 
                    }
                    this.stuck = true; 
                    this.velocity.set(0,0,0); 
                } else {
                    this.mesh.position.copy(nextPosition);
                }
                if (this.lifeTime <= 0) this.kill();
            }
            kill() {
                scene.remove(this.mesh);
                const idx = projectiles.indexOf(this);
                if(idx > -1) projectiles.splice(idx, 1);
            }
        }

        // --- Projectile System: Crossbow Bolt ---
        class CrossbowBolt {
            constructor(position, direction, damage) {
                this.damage = damage;
                this.lifeTime = 3.0; 
                this.mesh = new THREE.Group();
                this.mesh.position.copy(position);
                const offset = direction.clone().cross(new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(0.2);
                this.mesh.position.add(offset);
                this.mesh.position.y -= 0.2;
                const shaft = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.6), new THREE.MeshLambertMaterial({ color: 0x222222 }));
                this.mesh.add(shaft);
                const head = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.25, 4), new THREE.MeshLambertMaterial({ color: 0x555555 }));
                head.rotation.x = Math.PI / 2; head.position.set(0, 0, 0.425); 
                this.mesh.add(head);
                const f1 = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.03, 0.1), new THREE.MeshLambertMaterial({ color: 0x880000 }));
                f1.position.set(0.1, 0, -0.35); this.mesh.add(f1);
                const f2 = f1.clone(); f2.position.set(-0.1, 0, -0.35); this.mesh.add(f2);
                this.velocity = direction.clone().normalize().multiplyScalar(65); 
                this.gravity = new THREE.Vector3(0, -5, 0); 
                this.stuck = false;
                scene.add(this.mesh);
            }
            update(delta) {
                if (this.stuck || playerStats.isDead) return; 
                this.lifeTime -= delta;
                this.velocity.add(this.gravity.clone().multiplyScalar(delta));
                const displacement = this.velocity.clone().multiplyScalar(delta);
                const nextPosition = this.mesh.position.clone().add(displacement);
                const targetLook = this.mesh.position.clone().add(this.velocity);
                this.mesh.lookAt(targetLook);
                const direction = displacement.clone().normalize();
                const ray = new THREE.Raycaster(this.mesh.position, direction, 0, displacement.length());
                const allHits = [...ray.intersectObjects(objects), ...ray.intersectObjects(mobs.map(m => m.mesh), true)];
                if (allHits.length > 0) {
                    const hit = allHits[0];
                    const object = hit.object;
                    this.mesh.position.copy(hit.point).add(direction.clone().multiplyScalar(-0.1));
                    if (object.parent && object.parent.userData && object.parent.userData.type === 'mob') {
                        object.parent.userData.mobRef.hit(this.damage);
                        this.kill(); 
                        return; 
                    }
                    this.stuck = true; 
                    this.velocity.set(0,0,0); 
                } else {
                    this.mesh.position.copy(nextPosition);
                }
                if (this.lifeTime <= 0) this.kill();
            }
            kill() {
                scene.remove(this.mesh);
                const idx = projectiles.indexOf(this);
                if(idx > -1) projectiles.splice(idx, 1);
            }
        }

        // --- Projectile System: STRONGER Trident ---
        class TridentProjectile {
            constructor(position, direction, damage) {
                this.damage = damage;
                this.lifeTime = 2.5; 
                this.mesh = new THREE.Group();
                this.mesh.position.copy(position);
                const offset = direction.clone().cross(new THREE.Vector3(0, 1, 0)).normalize().multiplyScalar(0.2);
                this.mesh.position.add(offset);
                this.mesh.position.y -= 0.2;
                const shaft = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.8), new THREE.MeshLambertMaterial({ color: 0x555555 }));
                this.mesh.add(shaft);
                const p1 = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.2, 4), new THREE.MeshLambertMaterial({ color: 0xaaaaaa }));
                p1.rotation.x = Math.PI / 2; p1.position.set(0, 0, 0.5); this.mesh.add(p1);
                const p2 = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.2, 4), new THREE.MeshLambertMaterial({ color: 0xaaaaaa }));
                p2.rotation.x = Math.PI / 2; p2.rotation.z = -0.5; p2.position.set(-0.08, 0, 0.3); this.mesh.add(p2);
                const p3 = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.2, 4), new THREE.MeshLambertMaterial({ color: 0xaaaaaa }));
                p3.rotation.x = Math.PI / 2; p3.rotation.z = 0.5; p3.position.set(0.08, 0, 0.3); this.mesh.add(p3);
                this.velocity = direction.clone().normalize().multiplyScalar(55);
                this.velocity.y += 3;
                this.gravity = new THREE.Vector3(0, -12, 0); 
                this.stuck = false;
                this.trails = []; 
                this.trailTimer = 0;
                this.rotationSpeed = Math.random() * 20 + 10;
                scene.add(this.mesh);
            }
            update(delta) {
                if (this.stuck || playerStats.isDead) return; 
                this.lifeTime -= delta;
                this.mesh.rotation.z += this.rotationSpeed * delta;
                this.mesh.rotation.x += 5 * delta;
                this.velocity.add(this.gravity.clone().multiplyScalar(delta));
                const displacement = this.velocity.clone().multiplyScalar(delta);
                const nextPosition = this.mesh.position.clone().add(displacement);
                const targetLook = this.mesh.position.clone().add(this.velocity);
                this.mesh.lookAt(targetLook);
                this.trailTimer += delta;
                if (this.trailTimer > 0.04) {
                    this.trailTimer = 0;
                    const trailGeo = new THREE.BoxGeometry(0.04, 0.04, 0.8);
                    const trailMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.3 });
                    const trail = new THREE.Mesh(trailGeo, trailMat);
                    trail.position.copy(this.mesh.position);
                    trail.rotation.copy(this.mesh.rotation);
                    trail.lookAt(targetLook);
                    scene.add(trail);
                    this.trails.push({ mesh: trail, life: 0.5 });
                }
                for (let i = this.trails.length - 1; i >= 0; i--) {
                    const t = this.trails[i];
                    t.life -= delta;
                    t.mesh.material.opacity = t.life * 0.6; 
                    if (t.life <= 0) { scene.remove(t.mesh); this.trails.splice(i, 1); }
                }
                const direction = displacement.clone().normalize();
                const ray = new THREE.Raycaster(this.mesh.position, direction, 0, displacement.length());
                const allHits = [...ray.intersectObjects(objects), ...ray.intersectObjects(mobs.map(m => m.mesh), true)];
                if (allHits.length > 0) {
                    const hit = allHits[0];
                    const object = hit.object;
                    this.mesh.position.copy(hit.point).add(direction.clone().multiplyScalar(-0.1));
                    
                    const geo = new THREE.RingGeometry(0.2, 0.5, 16);
                    const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                    const shockwave = new THREE.Mesh(geo, mat);
                    shockwave.position.copy(hit.point);
                    shockwave.rotation.x = Math.PI / 2; 
                    scene.add(shockwave);
                    let scale = 1;
                    const expand = () => {
                        scale += 0.2; shockwave.scale.set(scale, scale, scale);
                        shockwave.material.opacity -= 0.05;
                        if (shockwave.material.opacity <= 0) { scene.remove(shockwave); } else { requestAnimationFrame(expand); }
                    };
                    expand();

                    if (object.parent && object.parent.userData && object.parent.userData.type === 'mob') {
                        object.parent.userData.mobRef.hit(this.damage);
                        this.kill(); 
                        return; 
                    }
                    this.stuck = true; 
                    this.velocity.set(0,0,0); 
                } else {
                    this.mesh.position.copy(nextPosition);
                }
                if (this.lifeTime <= 0) this.kill();
            }
            kill() {
                this.trails.forEach(t => scene.remove(t.mesh));
                this.trails = [];
                scene.remove(this.mesh);
                const idx = projectiles.indexOf(this);
                if(idx > -1) projectiles.splice(idx, 1);
            }
        }

        // --- Projectile System: EyeProjectile (Teleportation) ---
        class EyeProjectile {
            constructor(position, direction, controlsRef) {
                this.controls = controlsRef; 
                this.mesh = new THREE.Group();
                this.mesh.position.copy(position);
                const geometry = new THREE.SphereGeometry(0.15, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xb026ff });
                this.core = new THREE.Mesh(geometry, material);
                this.mesh.add(this.core);
                const wireGeo = new THREE.IcosahedronGeometry(0.25, 0);
                const wireMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true, transparent: true, opacity: 0.5 });
                this.shell = new THREE.Mesh(wireGeo, wireMat);
                this.mesh.add(this.shell);
                this.velocity = direction.clone().normalize().multiplyScalar(50); 
                this.lifeTime = 2.0;
                scene.add(this.mesh);
            }
            update(delta) {
                this.lifeTime -= delta;
                this.shell.rotation.y += 5 * delta;
                this.shell.rotation.z += 2 * delta;
                const displacement = this.velocity.clone().multiplyScalar(delta);
                const nextPosition = this.mesh.position.clone().add(displacement);
                const ray = new THREE.Raycaster(this.mesh.position, this.velocity.clone().normalize(), 0, displacement.length());
                const hits = ray.intersectObjects(objects);

                if (hits.length > 0) {
                    const hit = hits[0];
                    let spawnPos = hit.point.clone();
                    if (hit.face.normal.y > 0.5) spawnPos.y += 1.6;
                    else if (hit.face.normal.y < -0.5) spawnPos.y -= 1.6;
                    else spawnPos.add(hit.face.normal.clone().multiplyScalar(-0.5));
                    this.controls.getObject().position.copy(spawnPos);
                    velocity.set(0, 0, 0); 
                    canJump = true;
                    playerStats.fallDistance = 0; 

                    const flash = document.createElement('div');
                    flash.style.position = 'absolute'; flash.style.top = '0'; flash.style.left = '0';
                    flash.style.width = '100%'; flash.style.height = '100%';
                    flash.style.background = 'rgba(176, 38, 255, 0.5)';
                    flash.style.pointerEvents = 'none'; flash.style.transition = 'opacity 0.5s';
                    flash.style.zIndex = '100'; document.body.appendChild(flash);
                    setTimeout(() => { flash.style.opacity = '0'; setTimeout(() => flash.remove(), 500); }, 50);
                    this.kill();
                } else {
                    this.mesh.position.copy(nextPosition);
                }
                if (this.lifeTime <= 0) this.kill();
            }
            kill() {
                scene.remove(this.mesh);
                const idx = projectiles.indexOf(this);
                if(idx > -1) projectiles.splice(idx, 1);
            }
        }

        // --- MOB SYSTEM ---
        // Handles creation, AI behavior, and health of mobs
        class Mob {
            constructor(type, x, z) {
                this.type = type;
                this.mesh = new THREE.Group();
                this.mesh.position.set(x, 0, z);
                this.velocity = new THREE.Vector3();
                this.onGround = false;
                this.speed = 0.02 + Math.random() * 0.01;
                this.state = 'idle'; 
                this.timer = 0;
                this.bobOffset = Math.random() * 100;
                this.maxHealth = 100;
                this.health = 100;
                this.isDead = false;
                this.deathTimer = 0;
                this.meshParts = []; 
                if(type === 'chicken') { this.feetHeight = 0.15; this.xpReward = 2; } 
                if(type === 'cow') { this.feetHeight = 0.35; this.xpReward = 5; } 
                if(type === 'sheep') { this.feetHeight = 0.3; this.xpReward = 3; }  

                const whiteMat = new THREE.MeshLambertMaterial({ color: 0xffffff }).clone();
                const blackMat = new THREE.MeshLambertMaterial({ color: 0x111111 }).clone();
                const greyMat = new THREE.MeshLambertMaterial({ color: 0xaaaaaa }).clone();
                const orangeMat = new THREE.MeshLambertMaterial({ color: 0xffaa00 }).clone();
                const redMat = new THREE.MeshLambertMaterial({ color: 0xcc0000 }).clone();
                const pinkMat = new THREE.MeshLambertMaterial({ color: 0xffaaaa }).clone();

                const addPart = (geo, mat, pos) => {
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.copy(pos);
                    this.mesh.add(mesh);
                    this.meshParts.push(mesh);
                    mesh.userData.originalColor = mesh.material.color.clone();
                    return mesh;
                };

                if (type === 'chicken') {
                    addPart(new THREE.BoxGeometry(0.35, 0.35, 0.45), whiteMat, new THREE.Vector3(0, 0.3, 0));
                    addPart(new THREE.BoxGeometry(0.1, 0.25, 0.35), whiteMat, new THREE.Vector3(0.2, 0.3, 0));
                    addPart(new THREE.BoxGeometry(0.1, 0.25, 0.35), whiteMat, new THREE.Vector3(-0.2, 0.3, 0));
                    addPart(new THREE.BoxGeometry(0.25, 0.25, 0.25), whiteMat, new THREE.Vector3(0, 0.55, -0.25));
                    addPart(new THREE.BoxGeometry(0.06, 0.1, 0.06), redMat, new THREE.Vector3(0, 0.7, -0.25));
                    addPart(new THREE.BoxGeometry(0.04, 0.04, 0.1), orangeMat, new THREE.Vector3(0, 0.55, -0.4));
                    addPart(new THREE.BoxGeometry(0.04, 0.08, 0.04), redMat, new THREE.Vector3(0, 0.45, -0.35));
                    addPart(new THREE.BoxGeometry(0.03, 0.03, 0.03), blackMat, new THREE.Vector3(0.07, 0.58, -0.37));
                    addPart(new THREE.BoxGeometry(0.03, 0.03, 0.03), blackMat, new THREE.Vector3(-0.07, 0.58, -0.37));
                    addPart(new THREE.BoxGeometry(0.04, 0.15, 0.04), orangeMat, new THREE.Vector3(0.08, 0.1, 0));
                    addPart(new THREE.BoxGeometry(0.04, 0.15, 0.04), orangeMat, new THREE.Vector3(-0.08, 0.1, 0));
                } else if (type === 'cow') {
                    addPart(new THREE.BoxGeometry(1.0, 0.9, 0.6), whiteMat, new THREE.Vector3(0, 0.85, 0));
                    addPart(new THREE.BoxGeometry(0.3, 0.3, 0.61), blackMat, new THREE.Vector3(0.25, 1.0, 0));
                    addPart(new THREE.BoxGeometry(0.4, 0.5, 0.61), blackMat, new THREE.Vector3(-0.3, 0.8, 0));
                    addPart(new THREE.BoxGeometry(0.5, 0.5, 0.45), whiteMat, new THREE.Vector3(0, 1.25, -0.4));
                    addPart(new THREE.BoxGeometry(0.3, 0.2, 0.1), pinkMat, new THREE.Vector3(0, 1.1, -0.68));
                    addPart(new THREE.BoxGeometry(0.1, 0.1, 0.1), greyMat, new THREE.Vector3(0.2, 1.55, -0.45));
                    addPart(new THREE.BoxGeometry(0.1, 0.1, 0.1), greyMat, new THREE.Vector3(-0.2, 1.55, -0.45));
                    addPart(new THREE.BoxGeometry(0.05, 0.05, 0.05), blackMat, new THREE.Vector3(0.15, 1.3, -0.65));
                    addPart(new THREE.BoxGeometry(0.05, 0.05, 0.05), blackMat, new THREE.Vector3(-0.15, 1.3, -0.65));
                    const pos = [[0.3, 0.35, 0.2], [-0.3, 0.35, 0.2], [0.3, 0.35, -0.2], [-0.3, 0.35, -0.2]];
                    pos.forEach(p => addPart(new THREE.BoxGeometry(0.15, 0.4, 0.15), whiteMat, new THREE.Vector3(...p)));
                } else if (type === 'sheep') {
                    addPart(new THREE.BoxGeometry(0.8, 0.8, 0.6), whiteMat, new THREE.Vector3(0, 0.7, 0));
                    for(let i=0; i<6; i++) {
                        const f = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), whiteMat);
                        f.position.set((Math.random()-0.5)*0.8, 0.7 + (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.6);
                        this.mesh.add(f);
                        this.meshParts.push(f);
                        f.userData.originalColor = f.material.color.clone();
                    }
                    addPart(new THREE.BoxGeometry(0.35, 0.45, 0.35), greyMat, new THREE.Vector3(0, 0.85, -0.4));
                    addPart(new THREE.BoxGeometry(0.05, 0.15, 0.05), pinkMat, new THREE.Vector3(0.15, 0.95, -0.35));
                    addPart(new THREE.BoxGeometry(0.05, 0.15, 0.05), pinkMat, new THREE.Vector3(-0.15, 0.95, -0.35));
                    addPart(new THREE.BoxGeometry(0.06, 0.06, 0.06), blackMat, new THREE.Vector3(0.1, 0.95, -0.6));
                    addPart(new THREE.BoxGeometry(0.06, 0.06, 0.06), blackMat, new THREE.Vector3(-0.1, 0.95, -0.6));
                    const pos = [[0.25, 0.3, 0.2], [-0.25, 0.3, 0.2], [0.25, 0.3, -0.2], [-0.25, 0.3, -0.2]];
                    pos.forEach(p => addPart(new THREE.BoxGeometry(0.12, 0.3, 0.12), blackMat, new THREE.Vector3(...p)));
                }

                const fgGeo = new THREE.BoxGeometry(0.58, 0.06, 0.02);
                const fgMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                this.healthFg = new THREE.Mesh(fgGeo, fgMat);
                this.healthFg.position.set(0, 1.8, 0); 
                this.mesh.add(this.healthFg);

                this.mesh.userData = { type: 'mob', mobRef: this }; 
                scene.add(this.mesh);
                mobs.push(this);
            }

            update(delta) {
                if (this.isDead) {
                    this.deathTimer += delta;
                    if (this.mesh.rotation.x < Math.PI/2) {
                        this.mesh.rotation.x += 3 * delta;
                    }
                    if(this.deathTimer > 1.5) {
                        scene.remove(this.mesh);
                        const idx = mobs.indexOf(this);
                        if(idx > -1) mobs.splice(idx, 1);
                        addExp(this.xpReward); 
                    }
                    return;
                }

                this.timer += delta;
                this.velocity.x *= 0.85;
                this.velocity.z *= 0.85;

                // Simple AI State Machine
                if (this.timer > 2 + Math.random()) {
                    if (Math.random() > 0.5) {
                        this.state = 'walk';
                        this.mesh.rotation.y = Math.random() * Math.PI * 2;
                        this.timer = 0;
                    } else {
                        this.state = 'idle';
                        this.timer = 0;
                    }
                }

                if (this.state === 'walk') {
                    const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.mesh.quaternion);
                    const origin = this.mesh.position.clone();
                    origin.y += 0.5; 
                    const wallRay = new THREE.Raycaster(origin, dir, 0, 0.6);
                    const hits = wallRay.intersectObjects(objects);
                    
                    if (hits.length === 0) {
                        this.mesh.translateZ(-this.speed);
                    } else {
                        this.state = 'idle';
                        this.timer = 0;
                    }
                }

                this.mesh.position.x += this.velocity.x * delta * 10;
                this.mesh.position.z += this.velocity.z * delta * 10;

                // Gravity
                const downRay = new THREE.Raycaster(this.mesh.position, new THREE.Vector3(0, -1, 0), 0, 10);
                const groundHits = downRay.intersectObjects(objects);
                
                if (groundHits.length > 0) {
                    const groundY = groundHits[0].point.y;
                    this.mesh.position.y = groundY + this.feetHeight;
                    this.velocity.y = 0;
                } else {
                    this.velocity.y -= 20 * delta;
                    this.mesh.position.y += this.velocity.y * delta;
                }

                if (this.velocity.y === 0 && this.state === 'walk') {
                     this.mesh.position.y += Math.abs(Math.sin(performance.now() * 0.005 + this.bobOffset)) * 0.05;
                }

                const camPos = camera.position.clone();
                camPos.y = this.mesh.position.y + 1.8; 
                this.healthFg.lookAt(camPos);
            }

            hit(amount) {
                if (this.isDead) return;
                this.health -= amount;
                const scale = Math.max(0, this.health / this.maxHealth);
                this.healthFg.scale.x = scale;
                const width = 0.58;
                const shift = (width * (1 - scale)) / 2;
                this.healthFg.position.x = -shift; 

                if (this.health <= 0) {
                    this.isDead = true;
                } else {
                    // Knockback effect
                    const dir = new THREE.Vector3();
                    dir.subVectors(this.mesh.position, controls.getObject().position).normalize();
                    dir.y = 0.1; 
                    this.velocity.add(dir.multiplyScalar(1.2)); 
                    // Flash red on hit
                    this.meshParts.forEach(child => {
                        child.material.color.setHex(0xff0000);
                        setTimeout(() => {
                            if (child && child.material && child.userData.originalColor) {
                                child.material.color.copy(child.userData.originalColor);
                            }
                        }, 200);
                    });
                }
            }
        }

        // --- INITIALIZATION ---
        // Sets up Three.js scene, camera, renderer, and event listeners
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 2;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            const d = 80;
            dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
            dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
            scene.add(dirLight);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            const menu = document.getElementById('menu');
            const startBtn = document.getElementById('start-btn');

            startBtn.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => {
                if(!playerStats.isDead) menu.classList.add('hidden');
            });
            controls.addEventListener('unlock', () => {
                if(!playerStats.isDead) menu.classList.remove('hidden');
            });
            scene.add(controls.getObject());

            raycaster = new THREE.Raycaster();
            raycaster.far = 8; 

            // Selection box cursor
            const rollOverGeo = new THREE.BoxGeometry(1.01, 1.01, 1.01);
            const rollOverMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, opacity: 0.4, transparent: true });
            rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMat);
            scene.add(rollOverMesh);

            // WebGL Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Event Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseClick);
            document.addEventListener('wheel', onMouseWheel);
            window.addEventListener('resize', onWindowResize);

            // Setup everything else
            initMaterials();
            initUI();
            initWeaponsUI();
            initRPGUI(); 
            drawWeaponTexture(WEAPONS[0]);
            generateWorld();
            animate();
        }

        function initMaterials() {
            BLOCKS.forEach(block => {
                const tex = createProceduralTexture(block);
                const matOptions = { 
                    map: tex, 
                    transparent: block.style === 'leaves' ? true : false, 
                    opacity: block.style === 'leaves' ? 0.9 :1.0,
                    side: THREE.DoubleSide 
                };
                const mat = new THREE.MeshLambertMaterial(matOptions);

                if (block.style === 'grass') {
                    const sideCanvas = document.createElement('canvas');
                    sideCanvas.width = 64; sideCanvas.height = 64;
                    const sCtx = sideCanvas.getContext('2d');
                    sCtx.fillStyle = block.sideColor; sCtx.fillRect(0,0,64,64);
                    sCtx.fillStyle = block.color; sCtx.fillRect(0,0,64,15);
                    sCtx.fillStyle = 'rgba(0,0,0,0.2)';
                    for(let i=0; i<50; i++) sCtx.fillRect(Math.random()*64, Math.random()*64, 2, 2);
                    const sideTex = new THREE.CanvasTexture(sideCanvas);
                    sideTex.magFilter = THREE.NearestFilter;
                    
                    materials[block.id] = [
                        new THREE.MeshLambertMaterial({ map: sideTex }), 
                        new THREE.MeshLambertMaterial({ map: sideTex }), 
                        new THREE.MeshLambertMaterial({ map: tex }),     
                        new THREE.MeshLambertMaterial({ map: createProceduralTexture({color: block.sideColor, style:'dirt'}) }), 
                        new THREE.MeshLambertMaterial({ map: sideTex }), 
                        new THREE.MeshLambertMaterial({ map: sideTex })  
                    ];
                } else {
                    materials[block.id] = mat;
                }
            });
        }

        function initUI() {
            const hotbar = document.getElementById('hotbar');
            const hud = document.getElementById('hud-info');
            
            BLOCKS.forEach((block, index) => {
                const slot = document.createElement('div');
                slot.className = index === 0 ? 'slot active' : 'slot';
                slot.dataset.index = index;
                const key = document.createElement('span');
                key.className = 'slot-key';
                key.textContent = index + 1;
                slot.appendChild(key);
                const preview = document.createElement('div');
                preview.className = 'slot-preview';
                preview.style.backgroundColor = block.color;
                if(block.style === 'leaves') preview.style.opacity = 0.8;
                slot.appendChild(preview);
                hotbar.appendChild(slot);
            });

            window.updateHUD = () => {
                const weapon = WEAPONS[selectedWeaponIndex];
                hud.textContent = `Weapon: ${weapon.name} | Block: ${BLOCKS[selectedBlockIndex].name}`;
                
                const crosshair = document.getElementById('crosshair');
                const style = document.createElement('style');
                style.innerHTML = `#crosshair::before, #crosshair::after { background: ${weapon.color} !important; }`;
                document.head.appendChild(style);

                document.querySelectorAll('.slot').forEach((el, idx) => {
                    if(idx === selectedBlockIndex) el.classList.add('active');
                    else el.classList.remove('active');
                });
            };
            updateHUD();
        }

        function initWeaponsUI() {
            const weaponBar = document.getElementById('weapon-bar');
            weaponBar.innerHTML = '';
            WEAPONS.forEach((w, index) => {
                const slot = document.createElement('div');
                slot.className = index === 0 ? 'weapon-slot active' : 'weapon-slot';
                slot.dataset.index = index;
                
                const key = document.createElement('span');
                key.className = 'weapon-key';
                key.textContent = index + 1;
                
                slot.appendChild(key);
                slot.appendChild(document.createTextNode(w.name));
                weaponBar.appendChild(slot);
            });

            window.updateWeaponUI = () => {
                document.querySelectorAll('.weapon-slot').forEach((el, idx) => {
                    if(idx === selectedWeaponIndex) el.classList.add('active');
                    else el.classList.remove('active');
                });
                
                drawWeaponTexture(WEAPONS[selectedWeaponIndex]);
            };
            updateWeaponUI();
        }

        function generateWorld() {
            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const start = -CHUNK_SIZE/2;
            const end = CHUNK_SIZE/2;

            // Generate the ground plane
            for (let x = start; x < end; x++) {
                for (let z = start; z < end; z++) {
                    const y = -1;

                    const material = materials[1]; 
                    const voxel = new THREE.Mesh(geometry, material);
                    voxel.position.set(x, y, z); 
                    voxel.castShadow = true;
                    voxel.receiveShadow = true;
                    scene.add(voxel);
                    objects.push(voxel);

                    // Randomly place trees
                    if (Math.random() > 0.99 && x > -10 && x < 10 && z > -10 && z < 10) createTree(x, y+1, z);
                    
                    // Randomly place mobs
                    if (Math.random() > 0.998 && x > -30 && x < 30 && z > -30 && z < 30) {
                        const r = Math.random();
                        if(r < 0.4) new Mob('chicken', x, z);
                        else if(r < 0.7) new Mob('sheep', x, z);
                        else new Mob('cow', x, z);
                    }
                }
            }
        }

        function createTree(x, y, z) {
            const geo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            for(let i=0; i<4; i++) {
                const trunk = new THREE.Mesh(geo, materials[4]); 
                trunk.position.set(x, y+i, z);
                trunk.castShadow = true;
                trunk.receiveShadow = true;
                scene.add(trunk);
                objects.push(trunk);
            }
            const leafMat = materials[5]; 
            for(let lx = x-1; lx <= x+1; lx++) {
                for(let lz = z-1; lz <= z+1; lz++) {
                    for(let ly = y+3; ly <= y+4; ly++) {
                         if(lx===x && lz===z && ly===y+3) continue; 
                         const leaf = new THREE.Mesh(geo, leafMat);
                         leaf.position.set(lx, ly, lz);
                         leaf.castShadow = true;
                         leaf.receiveShadow = true;
                         scene.add(leaf);
                         objects.push(leaf);
                    }
                }
            }
        }

        // --- INPUT HANDLING ---
        function onMouseClick(event) {
            if (!controls.isLocked || playerStats.isDead) return;

            const weapon = WEAPONS[selectedWeaponIndex];

            // --- WEAPON ACTIONS (LEFT CLICK ONLY) ---
            
            // Magic: Teleportation Eye
            if (weapon.type === 'magic') {
                if (event.button === 0) { 
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    projectiles.push(new EyeProjectile(camera.position.clone(), dir, controls));
                }
                // Only return for left click, allow right click to fall through to building
                if (event.button === 0) return; 
            }

            // Ranged: Normal Bow
            if (weapon.type === 'ranged') {
                if (event.button === 0) {
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    projectiles.push(new Arrow(camera.position.clone(), dir, weapon.damage));
                }
                if (event.button === 0) return; 
            }
            
            // Ranged Heavy: Crossbow
            if (weapon.type === 'ranged_heavy') {
                if (event.button === 0) {
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    projectiles.push(new CrossbowBolt(camera.position.clone(), dir, weapon.damage));
                }
                if (event.button === 0) return;
            }

            // Throwable: Trident
            if (weapon.type === 'throwable') {
                if (event.button === 0) {
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    projectiles.push(new TridentProjectile(camera.position.clone(), dir, weapon.damage));
                }
                if (event.button === 0) return;
            }

            // --- INTERACTIONS (Works for ALL weapons now) ---
            // We check hits on objects (blocks) and mobs
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersectObjects = [...objects];
            mobs.forEach(m => intersectObjects.push(m.mesh));

            const intersects = raycaster.intersectObjects(intersectObjects, true); 

            if (intersects.length > 0) {
                const intersect = intersects[0];
                
                let object = intersect.object;
                // Traverse up to find the root group (for mobs)
                while(object.parent && object.parent.type !== 'Scene') {
                    object = object.parent;
                }
                
                // --- LEFT CLICK: Attack/Mine ---
                if (object.userData && object.userData.type === 'mob') {
                    if (event.button === 0) {
                        object.userData.mobRef.hit(weapon.damage); 
                    }
                    // If we hit a mob with right click, don't build a block inside it
                    return; 
                }

                if (event.button === 0) {
                    // Mine block
                    scene.remove(intersect.object);
                    const index = objects.indexOf(intersect.object);
                    if (index > -1) objects.splice(index, 1);
                } 
                // --- RIGHT CLICK: Build (Now works with any weapon) ---
                else if (event.button === 2) {
                    const voxelPos = new THREE.Vector3();
                    voxelPos.copy(intersect.object.position).add(intersect.face.normal);
                    
                    // Prevent placing block inside player
                    const playerPos = controls.getObject().position;
                    if (Math.abs(voxelPos.x - playerPos.x) < 0.8 &&
                        Math.abs(voxelPos.z - playerPos.z) < 0.8 &&
                        (voxelPos.y - playerPos.y) < 0.5 && 
                        (voxelPos.y - playerPos.y) > -2.0) {
                        return;
                    }
                    addBlock(voxelPos);
                }
            }
        }

        function addBlock(position) {
            const blockDef = BLOCKS[selectedBlockIndex];
            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const material = materials[blockDef.id];
            const voxel = new THREE.Mesh(geometry, material);
            voxel.position.copy(position);
            voxel.castShadow = true;
            voxel.receiveShadow = true;
            scene.add(voxel);
            objects.push(voxel);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'ShiftLeft': case 'ShiftRight': sprint = true; break;
                case 'Space': 
                    if ( canJump === true && velocity.y >= -0.1 && !playerStats.isDead) { 
                        velocity.y = 12; 
                        canJump = false;
                    }
                    break;
                
                case 'Digit1': selectedBlockIndex = 0; updateHUD(); break;
                case 'Digit2': selectedBlockIndex = 1; updateHUD(); break;
                case 'Digit3': selectedBlockIndex = 2; updateHUD(); break;
                case 'Digit4': selectedBlockIndex = 3; updateHUD(); break;
                case 'Digit5': selectedBlockIndex = 4; updateHUD(); break;
                case 'Digit6': selectedBlockIndex = 5; updateHUD(); break;
                case 'Digit7': selectedBlockIndex = 6; updateHUD(); break;
                case 'Digit8': selectedBlockIndex = 7; updateHUD(); break;
                case 'Digit9': selectedBlockIndex = 8; updateHUD(); break;
                case 'Digit0': selectedBlockIndex = 9; updateHUD(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': case 'ShiftRight': sprint = false; break;
            }
        }

        function onMouseWheel(event) {
            if (playerStats.isDead) return;
            if (event.deltaY > 0) {
                selectedWeaponIndex = (selectedWeaponIndex + 1) % WEAPONS.length;
            } else {
                selectedWeaponIndex = (selectedWeaponIndex - 1 + WEAPONS.length) % WEAPONS.length;
            }
            updateHUD();
            updateWeaponUI();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- MAIN GAME LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1);

            // Update projectiles
            for(let i = projectiles.length - 1; i >= 0; i--) {
                projectiles[i].update(delta);
            }

            // Update mobs
            mobs.forEach(mob => mob.update(delta));

            // --- Player Physics & Controls ---
            if (controls.isLocked === true) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 40.0 * delta; 

                const currentSpeed = sprint ? 8.0 : 4.0;
                const speed = currentSpeed * delta;

                let moveX = 0;
                let moveZ = 0;
                if (moveLeft) moveX -= 1;
                if (moveRight) moveX += 1;
                if (moveForward) moveZ += 1;
                if (moveBackward) moveZ -= 1;

                if (moveX !== 0) {
                    controls.moveRight(moveX * speed);
                    const pos = controls.getObject().position.clone();
                    const ray = new THREE.Raycaster(pos, new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion), 0, 0.5);
                    const hits = ray.intersectObjects(objects);
                    if (hits.length > 0) controls.moveRight(-moveX * speed);
                }

                if (moveZ !== 0) {
                    controls.moveForward(moveZ * speed);
                    const pos = controls.getObject().position.clone();
                    const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                    const ray = new THREE.Raycaster(pos, dir, 0, 0.5);
                    const hits = ray.intersectObjects(objects);
                    if (hits.length > 0) controls.moveForward(-moveZ * speed);
                }

                const playerPos = controls.getObject().position.clone();
                
                // Fall damage calculation
                if (velocity.y < 0) {
                    playerStats.fallDistance += (-velocity.y * delta);
                }
                
                playerPos.y -= 0.1; 
                const downRay = new THREE.Raycaster(playerPos, new THREE.Vector3(0, -1, 0), 0, 10); 
                const hits = downRay.intersectObjects(objects);

                if (hits.length > 0) {
                    const hit = hits[0];
                    if (hit.distance <= 1.6 && velocity.y <= 0 && hit.face.normal.y > 0.5) {
                        controls.getObject().position.y = hit.point.y + 1.6;
                        velocity.y = Math.max(0, velocity.y);
                        
                        if (playerStats.fallDistance > 6) {
                            const dmg = Math.floor((playerStats.fallDistance - 6) * 2); 
                            if (dmg > 0) takeDamage(dmg);
                        }
                        playerStats.fallDistance = 0; 
                        
                        canJump = true;
                    }
                }
                
                controls.getObject().position.y += velocity.y * delta;

                // Respawn if fell off the world
                if (controls.getObject().position.y < -20) {
                    takeDamage(20); 
                    velocity.y = 0;
                    controls.getObject().position.set(0, 5, 0);
                    canJump = false;
                }

                // Update block cursor
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(objects);
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    rollOverMesh.position.copy(intersect.object.position);
                    rollOverMesh.visible = true;
                } else {
                    rollOverMesh.visible = false;
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        // --- START EVERYTHING ---
        init();

    </script>
</body>
</html>
